<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three-Body Problem Simulation</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Inter', sans-serif; background-color: #0d0d1f; }
        canvas { display: block; }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: #ffffff;
            background: rgba(0, 0, 0, 0.6);
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 14px;
            max-width: 300px;
        }
        #controls {
            position: absolute;
            bottom: 10px;
            right: 10px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.6);
            border-radius: 8px;
            color: white;
            display: flex;
            flex-direction: column;
            gap: 8px;
            min-width: 250px;
        }
    </style>
</head>
<body>
    <div id="info">
        <h1 class="text-lg font-bold mb-1">Three-Body Problem</h1>
        <p>Observe the chaotic gravitational dance of three celestial bodies. The motion is non-repeating and highly sensitive to initial conditions. **Parameters are randomized on reset.**</p>
        <p class="mt-2 text-sm">Use the mouse to orbit and the **scroll wheel to zoom**.</p>
    </div>
    <div id="controls">
        <!-- Speed Control Section -->
        <div class="flex items-center justify-between text-sm">
            <label for="speedSlider">Simulation Speed:</label>
            <span id="speedValue" class="font-bold text-yellow-300">1.0x</span>
        </div>
        <input type="range" id="speedSlider" min="0.1" max="25.0" step="0.1" value="1.0" class="w-full accent-indigo-500">
        
        <div class="h-2"></div>

        <button id="resetButton" class="px-3 py-1 bg-indigo-600 hover:bg-indigo-700 rounded-lg transition shadow-md">Reset Simulation</button>
    </div>

    <script>
        // --- GLOBAL CONSTANTS & VARIABLES (Using var for global scope consistency) ---
        var scene, camera, renderer, animationId;
        var G = 0.5; // Gravitational constant
        var baseTimeStep = 0.01;
        var timeStep = baseTimeStep;
        var cameraDistance = 200; 

        var bodies = [];
        var speedSlider;
        var speedValueSpan;

        // --- BODY CLASS: Encapsulates Body State and Visuals ---
        class Body {
            constructor(config, scene) {
                // Physics Properties
                this.mass = config.mass;
                this.position = config.pos.clone();
                this.velocity = config.vel.clone();
                this.acceleration = new THREE.Vector3(0, 0, 0);

                // Visual Mesh
                const geometry = new THREE.SphereGeometry(config.radius, 32, 32);
                const material = new THREE.MeshPhongMaterial({ 
                    color: config.color, 
                    emissive: config.color, 
                    emissiveIntensity: 0.4 
                });
                this.mesh = new THREE.Mesh(geometry, material);
                this.mesh.position.copy(this.position);
                scene.add(this.mesh);

                // Trail Line
                const trailLength = 500;
                this.trailPositions = new Float32Array(trailLength * 3);
                const trailGeometry = new THREE.BufferGeometry();
                trailGeometry.setAttribute('position', new THREE.BufferAttribute(this.trailPositions, 3));
                const trailMaterial = new THREE.LineBasicMaterial({ color: config.color, linewidth: 1 });
                this.trail = new THREE.Line(trailGeometry, trailMaterial);
                scene.add(this.trail);
                this.trailIndex = 0;
                this.maxTrailIndex = trailLength;
            }

            // Applies physics step and updates visuals (mesh and trail)
            update(dt) {
                // Apply half of the velocity change and update position
                this.velocity.addScaledVector(this.acceleration, dt);
                this.position.addScaledVector(this.velocity, dt);
                this.acceleration.set(0, 0, 0); // Reset acceleration

                // Update mesh position
                this.mesh.position.copy(this.position);

                // Update trail position (more concise)
                const i = this.trailIndex * 3;
                this.trailPositions[i] = this.position.x;
                this.trailPositions[i + 1] = this.position.y;
                this.trailPositions[i + 2] = this.position.z;

                this.trailIndex = (this.trailIndex + 1) % this.maxTrailIndex;

                // Close the loop to ensure a continuous line when wrapping
                const nextIndex = this.trailIndex * 3;
                this.trailPositions[nextIndex] = this.position.x;
                this.trailPositions[nextIndex + 1] = this.position.y;
                this.trailPositions[nextIndex + 2] = this.position.z;

                this.trail.geometry.attributes.position.needsUpdate = true;
                this.trail.geometry.setDrawRange(0, this.maxTrailIndex);
            }
        }

        // --- CORE FUNCTIONS ---

        function generateRandomBodyConfig() {
            const bodyCount = 3;
            const colors = [0xff4757, 0x2ed573, 0x1e90ff];
            const minMass = 5, maxMass = 15;
            const maxPos = 60;
            const maxVel = 5;

            const configs = [];
            for (let i = 0; i < bodyCount; i++) {
                const mass = minMass + Math.random() * (maxMass - minMass);
                const radius = mass / 3; 
                const pos = new THREE.Vector3(
                    (Math.random() - 0.5) * maxPos * 2,
                    (Math.random() - 0.5) * maxPos * 0.5,
                    (Math.random() - 0.5) * maxPos * 2
                );
                const vel = new THREE.Vector3(
                    (Math.random() - 0.5) * maxVel * 2,
                    (Math.random() - 0.5) * maxVel * 2,
                    (Math.random() - 0.5) * maxVel * 2
                );

                configs.push({ mass, radius, color: colors[i], pos, vel });
            }
            return configs;
        }

        function calculateForces(bodies) {
            const minR = 10;
            for (let i = 0; i < bodies.length; i++) {
                const body1 = bodies[i];
                for (let j = i + 1; j < bodies.length; j++) {
                    const body2 = bodies[j];

                    // Calculate displacement vector rVec (body2 - body1)
                    const rVec = new THREE.Vector3().subVectors(body2.position, body1.position);
                    let rSq = rVec.lengthSq(); 
                    
                    // Softening potential
                    const rClamped = Math.max(rSq, minR * minR);

                    // F = G * m1 * m2 / r^2
                    const forceMagnitude = (G * body1.mass * body2.mass) / rClamped;

                    // Calculate force vector and acceleration
                    const rDir = rVec.normalize();
                    const F = rDir.multiplyScalar(forceMagnitude);

                    // Apply forces: a = F / m
                    body1.acceleration.addScaledVector(F, -1 / body1.mass); // F on 1 is negative F
                    body2.acceleration.addScaledVector(F, 1 / body2.mass);  // F on 2 is F
                }
            }
        }

        function animate() {
            animationId = requestAnimationFrame(animate);
            calculateForces(bodies);
            bodies.forEach(body => body.update(timeStep));
            renderer.render(scene, camera);
        }

        // --- UTILITY/CONTROL FUNCTIONS ---

        function init() {
            speedSlider = document.getElementById('speedSlider');
            speedValueSpan = document.getElementById('speedValue');
            
            // Renderer setup
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // Scene and Camera setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0d0d1f);
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(cameraDistance, cameraDistance / 2, cameraDistance);
            camera.lookAt(0, 0, 0);

            // Lighting
            scene.add(new THREE.AmbientLight(0x404040));
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(1000, 1000, 1000); 
            scene.add(directionalLight);

            // Starfield
            createStarfield(1000, 500);

            // Event listeners
            window.addEventListener('resize', onWindowResize);
            document.getElementById('resetButton').addEventListener('click', resetSimulation);
            speedSlider.addEventListener('input', updateSpeed);
            renderer.domElement.addEventListener('wheel', handleZoom, false);
            setupMouseControls();

            resetSimulation(); // Initial setup of bodies and start animation
        }

        function createStarfield(extent, count) {
            const starGeometry = new THREE.BufferGeometry();
            const starMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: 0.5, sizeAttenuation: true });
            const starVertices = [];
            for (let i = 0; i < count; i++) {
                starVertices.push(
                    (Math.random() - 0.5) * extent,
                    (Math.random() - 0.5) * extent,
                    (Math.random() - 0.5) * extent
                );
            }
            starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));
            scene.add(new THREE.Points(starGeometry, starMaterial));
        }
        
        function updateSpeed(event) {
            const speedFactor = parseFloat(event.target.value);
            timeStep = baseTimeStep * speedFactor;
            speedValueSpan.textContent = `${speedFactor.toFixed(1)}x`;
        }

        function handleZoom(event) {
            event.preventDefault();

            const zoomSpeed = 0.1;
            const minDistance = 50;
            const maxDistance = 1500;
            const direction = camera.position.clone().normalize();

            if (event.deltaY > 0) {
                cameraDistance = Math.min(maxDistance, cameraDistance + cameraDistance * zoomSpeed);
            } else {
                cameraDistance = Math.max(minDistance, cameraDistance - cameraDistance * zoomSpeed);
            }

            camera.position.copy(direction).multiplyScalar(cameraDistance);
            camera.lookAt(0, 0, 0);
        }
        
        var isDragging = false;
        var previousMousePosition = { x: 0, y: 0 };
        const rotationSpeed = 0.005;

        function setupMouseControls() {
            const domElement = renderer.domElement;

            domElement.addEventListener('mousedown', (e) => {
                isDragging = true;
                previousMousePosition.x = e.clientX;
                previousMousePosition.y = e.clientY;
            });

            domElement.addEventListener('mouseup', () => {
                isDragging = false;
            });

            domElement.addEventListener('mousemove', (e) => {
                if (!isDragging) return;

                const deltaX = e.clientX - previousMousePosition.x;
                const deltaY = e.clientY - previousMousePosition.y;

                const offset = camera.position.clone();
                const up = new THREE.Vector3(0, 1, 0);

                // Rotate around the Y-axis (Yaw)
                const quaternionY = new THREE.Quaternion().setFromAxisAngle(up, -deltaX * rotationSpeed);
                offset.applyQuaternion(quaternionY);

                // Rotate around the local X-axis (Pitch)
                const localXAxis = camera.localToWorld(new THREE.Vector3(1, 0, 0)).normalize();
                const quaternionX = new THREE.Quaternion().setFromAxisAngle(localXAxis, -deltaY * rotationSpeed);
                offset.applyQuaternion(quaternionX);

                camera.position.copy(offset);
                camera.lookAt(0, 0, 0);
                
                cameraDistance = camera.position.length();

                previousMousePosition.x = e.clientX;
                previousMousePosition.y = e.clientY;
            });

            domElement.addEventListener('contextmenu', (e) => e.preventDefault());
        }
        
        function resetSimulation() {
            // Stop animation
            if (animationId) cancelAnimationFrame(animationId);

            // Clean up: Remove all previous bodies' meshes and trails from the scene
            while(bodies.length) {
                const body = bodies.pop();
                scene.remove(body.mesh);
                scene.remove(body.trail);
            }
            
            // Reset camera to default view
            cameraDistance = 200; 
            camera.position.set(cameraDistance, cameraDistance / 2, cameraDistance);
            camera.lookAt(0, 0, 0);

            // Create and add new bodies
            const randomConfig = generateRandomBodyConfig();
            randomConfig.forEach(config => {
                // Ensure new unique vectors for each body
                bodies.push(new Body(config, scene));
            });

            // Re-start animation
            if (renderer) {
                animate();
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Start the application when the window loads
        window.onload = init;
    </script>
</body>
</html>
